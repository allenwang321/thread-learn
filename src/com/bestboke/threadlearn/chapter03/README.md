### 线程sleep

sleep是一个静态方法，有两个重载方法一个需要传入毫秒数，一个需要传入毫秒数和纳秒数。
源码中关于第二方法则是当纳秒数大于500000或者毫秒数为零时将毫秒数++然后调用第一个方法。

### 线程yield

yield一种启发式的方法，会提醒调度器我愿意放弃当前CPU的资源，但是如果CPU的资源不紧张时则会忽略这种提醒。

- sleep会导致当前线程暂停指定时间，没有CPU时间片的消耗。
- yield只是对CPU调度器的一个提示，如果CPU调度器没有忽略这个提示，就会导致上下文的切换。
- sleep会导致线程短暂block，会在给定时间内释放CPU资源。
- yield会使RUNNING状态的Thread进入RUNNABLE状态(如果CPU调度器没有忽略这个提示)。
- sleep几乎百分百地完成了给定时间的休眠，而yield的提示并不能一定担保。
- 一个线程sleep另一个线程调用interrupt会捕获到中断信号，而yield则不会。

### 线程优先级

理论上来讲优先级比较高的线程会优先获取被CPU调度的机会，但是实际上并不是，所以不要在程序设计中依赖优先级来进行业务场景的操作，在不同的情况下运行的结果并不是完全按照优先级得到的结果。

- 线程的优先级不能大于10也不能小于1，也不能大于所在线程组的最大优先级。
- 线程的默认优先级和它的父类保持一致，一般都是5，因为main线程的优先级就是5。

### 线程interrupt

**中断方法**

- `public void interrupt()` 中断线程。
- `public static boolean interrupted()` 查询当前线程中断状态，如果已经发生中断，就清除中断状态并返回true。
- `public boolean isInterruputed()` 仅仅是查询当前线程是否是中断状态。

**interrupt**

当线程进入阻塞状态时，另外一个线程调用被阻塞线程的interrupt方法，则会打断当前线程的阻塞状态，打断线程并不是意味着该线程的生命周期已经结束，仅仅是打断了阻塞状态。  
线程被打断时会抛出一个`InterruptedException`异常。