### 线程sleep

`sleep()`是一个静态方法，有两个重载方法一个需要传入毫秒数，一个需要传入毫秒数和纳秒数。  
源码中关于第二方法则是当纳秒数大于500000或者毫秒数为零时将毫秒数++然后调用第一个方法。  

### 线程yield

`yield()`一种启发式的方法，会提醒调度器我愿意放弃当前CPU的资源，但是如果CPU的资源不紧张时则会忽略这种提醒。  

- `sleep()`会导致当前线程暂停指定时间，没有CPU时间片的消耗。  
- `yield()`只是对CPU调度器的一个提示，如果CPU调度器没有忽略这个提示，就会导致上下文的切换。  
- `sleep()`会导致线程短暂block，会在给定时间内释放CPU资源。  
- `yield()`会使RUNNING状态的Thread进入RUNNABLE状态(如果CPU调度器没有忽略这个提示)。  
- `sleep()`几乎百分百地完成了给定时间的休眠，而`yield()`的提示并不能一定担保。  
- 一个线程`sleep()`另一个线程调用`interrupt()`会捕获到中断信号，而`yield()`则不会。  

### 线程优先级

理论上来讲优先级比较高的线程会优先获取被CPU调度的机会，但是实际上并不是，所以不要在程序设计中依赖优先级来进行业务场景的操作，在不同的情况下运行的结果并不是完全按照优先级得到的结果。  

- 线程的优先级不能大于10也不能小于1，也不能大于所在线程组的最大优先级。
- 线程的默认优先级和它的父类保持一致，一般都是5，因为main线程的优先级就是5。

### 线程interrupt

**中断方法**

- `public void interrupt()` 中断线程。
- `public boolean isInterruputed()` 仅仅是查询当前线程是否是中断状态。
- `public static boolean interrupted()` 查询当前线程中断状态，如果已经发生中断，就清除中断状态并返回true。

**interrupt()**

当线程进入阻塞状态时，另外一个线程调用被阻塞线程的`interrupt()`方法，则会打断当前线程的阻塞状态，打断线程并不是意味着该线程的生命周期已经结束，仅仅是打断了阻塞状态。  
线程阻塞发生中断时会抛出一个`InterruptedException`异常。  
当线程正在运行时调用`interrupt()`方法时并不会抛出`InterruptedException`异常，也就是不会中断正在运行的进程。

**isInterruputed()**

`isInterrupted()` 方法仅仅是判断是否是处于中断状态。  
`interrupt()`方法源码如下  

![](http://ww2.sinaimg.cn/large/006tNc79gy1g3b7mzhkc1j31m40e0jti.jpg)

可以看到其中的一句注释 *`// Just to set the interrupt flag`*   
线程是否是中断状态是依据中断标识来进行判断。  
被阻塞的线程中断抛出异常后中断的标识将会被复位。 

**interrupted()**

`interrupted()`方法在判断当前线程是否是在中断状态的同时将中断的标识复位，类似于`get()`之后又执行了`set()`操作。  
也就是讲当线程被中断后第一次执行了`interrupted()`方法之后返回的是`true`，后面继续执行返回的都是`false`。  
下图是关于`isInterrupted()`与`interrupted()`方法源码部分。  

![](http://ww4.sinaimg.cn/large/006tNc79gy1g3biq89gosj31cm0u012v.jpg)

最终执行的是一个私有的`native`方法`isInterrupted()`,只是`interrupted()`传入的参数是`ture`而`isInterrupted()`传入的是`false`,
这里的`true`和`false`代表是否重置线程的中断标识。  

### 线程join

`join`某个线程B，会使当前线程A进入等待状态，直到线程B结束生命周期或者到达给定时间，此时的A线程是处于`BLOCKED`状态的，而不是B。 

### 线程的run和start

- `run()`方法是在启动线程之后由jvm虚拟机直接调用的，如果手动调用则仅仅是相当于一个方法调用，还是由原来的线程去执行并不是新建的线程执行。所以直接调用`run()`和创建多线程的初衷是相违背的。  
- `start()`方法是启动一个新的线程，然后新的线程自己回去执行`run()`方法。该方法是真正意义上的启动线程，会出现异步执行的效果。  

![](http://ww4.sinaimg.cn/large/006tNc79gy1g3h5gth759j317f0u045k.jpg)

如上图所示，调用`start()`方法执行`run()`的是`t1`线程，而直接调用`run()`执行的时候是`main`线程，并不是new出来的`t2`线程。


jdk中有一个`stop()`方法，但是该方法存在问题，在关闭线程时并不会释放掉监视器的锁，所以该方法不适用。jdk官方可能在接下来的版本中移除该方法，现在该方法显示的是即将废弃的状态。

### 线程的正常关闭

#### 1. 线程结束生命周期正常结束 

线程运行结束后，完成了自己的使命之后就会正常退出，如果线程中的任务耗时比较短或者时间可控，即可以让他正常结束。  

#### 2. 捕获中断信号关闭线程

通过检查线程的`interrupt`的标识来决定是否退出，执行某个可中断的方法通过捕获中断信号来决定是否退出。  

#### 3. 使用volatile开关控制

由于线程的`interrupt`标识是可擦除的，或者在逻辑单元中不会调用任何可中断方法，所以使用`volatile`修饰的开关flag关闭线程。
